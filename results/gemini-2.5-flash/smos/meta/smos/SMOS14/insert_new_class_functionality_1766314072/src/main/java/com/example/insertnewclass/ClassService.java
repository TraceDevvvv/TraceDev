```java
package com.example.insertnewclass;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Service class responsible for handling business logic related to Class entities.
 * This includes validating class data and persisting new classes to the archive.
 * It acts as an intermediary between the controller and the data access layer (repository).
 */
@Service
public class ClassService {

    private final ClassRepository classRepository;

    // Regex pattern for academic year validation (e.g., 2024-2025).
    // This pattern captures the two four-digit years for range validation.
    private static final Pattern ACADEMIC_YEAR_PATTERN = Pattern.compile("^(\\d{4})-(\\d{4})$");

    /**
     * Constructs a ClassService with the given ClassRepository.
     * Spring's dependency injection will automatically provide the ClassRepository instance.
     *
     * @param classRepository The repository for ClassEntity operations.
     */
    @Autowired
    public ClassService(ClassRepository classRepository) {
        this.classRepository = classRepository;
    }

    /**
     * Creates a new class in the archive after validating the provided data.
     * This method orchestrates the business logic for inserting a new class.
     *
     * @param request The {@link ClassCreateRequest} containing the data for the new class.
     * @return A {@link ClassResponse} object representing the newly created class, including its generated ID.
     * @throws InvalidClassDataException If the provided class data is invalid according to business rules.
     */
    public ClassResponse createClass(ClassCreateRequest request) {
        // Perform business logic validation.
        // Basic format and presence validation (e.g., @NotBlank, @Size, @Pattern)
        // are typically handled by @Valid annotation in the controller layer.
        // This service-level validation focuses on more complex business rules.
        validateClassData(request);

        // Convert the Data Transfer Object (DTO) to a JPA Entity.
        // The ID is not set here as it will be generated by the database upon saving.
        ClassEntity classEntity = new ClassEntity(
            request.getName(),
            request.getAddress(),
            request.getAcademicYear()
        );

        // Save the entity to the database via the repository.
        // The saved entity will have the generated ID populated.
        ClassEntity savedClassEntity = classRepository.save(classEntity);

        // Convert the saved Entity back to a Response DTO to be returned to the client.
        return new ClassResponse(
            savedClassEntity.getId(),
            savedClassEntity.getName(),
            savedClassEntity.getAddress(),
            savedClassEntity.getAcademicYear()
        );
    }

    /**
     * Validates the business rules for class creation data.
     * This private method encapsulates specific business logic validations that go beyond
     * simple field constraints (which are handled by JSR-303 annotations on {@link ClassCreateRequest}).
     *
     * @param request The {@link ClassCreateRequest} containing the data to validate.
     * @throws InvalidClassDataException If any business rule validation fails, providing a descriptive message.
     */
    private void validateClassData(ClassCreateRequest request) {
        // Validate academic year range: Ensure the second year is exactly one year after the first year.
        // Example: "2024-2025" is valid, "2024-2026" is invalid.
        Matcher matcher = ACADEMIC_YEAR_PATTERN.matcher(request.getAcademicYear());

        // Although @Pattern on ClassCreateRequest should catch format issues,
        // this check ensures the format is correct before parsing, adding robustness.
        if (!matcher.matches()) {
            throw new InvalidClassDataException("Academic year must be in YYYY-YYYY format.");
        }

        try {
            // Extract and parse the start and end years from the academic year string.
            int startYear = Integer.parseInt(matcher.group(1));
            int endYear = Integer.parseInt(matcher.group(2));

            // Business rule: The end year must be exactly one year greater than the start year.
            if (endYear != startYear + 1) {
                throw new InvalidClassDataException("Academic year range is invalid. The second year must be exactly one year after the first year (e.g., 2024-2025).");
            }
        } catch (NumberFormatException e) {
            // This catch block handles potential issues during integer parsing,
            // though unlikely if the regex pattern is correctly applied.
            throw new InvalidClassDataException("Failed to parse academic year. Ensure years are valid numbers.", e);
        }

        // Add any other