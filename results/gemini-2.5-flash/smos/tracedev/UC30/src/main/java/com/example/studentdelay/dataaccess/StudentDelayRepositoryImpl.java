
package com.example.studentdelay.dataaccess;

import com.example.studentdelay.domain.DelayRecord;
import com.example.studentdelay.domain.Student;
import com.example.studentdelay.util.ConnectionException;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Objects;

/**
 * Implementation of the IStudentDelayRepository interface, interacting with SMOSServerConnector.
 * Handles conversions between domain entities (DelayRecord, Student) and raw data maps for SMOS.
 */
public class StudentDelayRepositoryImpl implements IStudentDelayRepository {
    private final SMOSServerConnector smosServerConnector;

    // Date formatters for converting between LocalDate/LocalDateTime and String for SMOS data
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE;
    private static final DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    public StudentDelayRepositoryImpl(SMOSServerConnector smosServerConnector) {
        this.smosServerConnector = smosServerConnector;
    }

    /**
     * Saves a DelayRecord by converting it to a Map, sending it via SMOSServerConnector,
     * and then updating the DelayRecord with any generated ID.
     *
     * @param delayRecord The DelayRecord to save.
     * @return The saved DelayRecord, potentially with an updated ID.
     * @throws ConnectionException if the SMOS server connection fails.
     */
    @Override
    public DelayRecord save(DelayRecord delayRecord) throws ConnectionException {
        System.out.println("Repository: Saving DelayRecord: " + delayRecord.getStudentId());

        // Convert DelayRecord to a Map suitable for SMOSConnector
        Map<String, Object> delayDataMap = new HashMap<>();
        // ID might be null for new records, SMOSConnector will assign
        if (delayRecord.getId() != null) {
            delayDataMap.put("id", delayRecord.getId());
        }
        delayDataMap.put("studentId", delayRecord.getStudentId());
        delayDataMap.put("delayDate", delayRecord.getDelayDate().format(DATE_FORMATTER));
        delayDataMap.put("reason", delayRecord.getReason());
        delayDataMap.put("entryTimestamp", delayRecord.getEntryTimestamp().format(DATETIME_FORMATTER));

        try {
            // SMOSConnector -> SMOS (sendData)
            Map<String, Object> savedRecordConfirmation = smosServerConnector.sendData(delayDataMap);

            // Update the DelayRecord with the ID generated by SMOS (if any)
            if (savedRecordConfirmation != null && savedRecordConfirmation.containsKey("id")) {
                delayRecord.setId((String) savedRecordConfirmation.get("id"));
            }
            System.out.println("Repository: DelayRecord saved with ID: " + delayRecord.getId());
            return delayRecord;
        } catch (ConnectionException e) {
            // Propagate the ConnectionException up
            System.err.println("Repository: Failed to save data due to connection error: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Finds DelayRecords by a specific date. Converts the date to a query map,
     * fetches data from SMOS, and then converts the resulting maps to DelayRecord entities.
     *
     * @param date The date to query for.
     * @return A list of DelayRecord entities.
     * @throws ConnectionException if the SMOS server connection fails.
     */
    @Override
    public List<DelayRecord> findByDate(LocalDate date) throws ConnectionException {
        System.out.println("Repository: Finding DelayRecords for date: " + date);

        Map<String, Object> dateQuery = new HashMap<>();
        dateQuery.put("delayDate", date.format(DATE_FORMATTER));

        try {
            // SMOSConnector -> SMOS (fetchData)
            List<Map<String, Object>> delayDataList = smosServerConnector.fetchData(dateQuery);
            List<DelayRecord> delayRecords = new ArrayList<>();

            // Convert List<Map<String, Object>> to List<DelayRecord>
            for (Map<String, Object> data : delayDataList) {
                // Ensure it's a delay record (not student data)
                if (data.containsKey("id") && data.containsKey("studentId") && data.containsKey("delayDate")) {
                    // The compilation error indicates that DelayRecord.create does not have a 5-argument signature.
                    // The error message suggests a create method with signature (String, LocalDate, String) exists.
                    // Assuming this corresponds to (studentId, delayDate, reason) and that DelayRecord is mutable
                    // given the use of setId() in the save method.
                    DelayRecord record = DelayRecord.create(
                            (String) data.get("studentId"), // First String
                            LocalDate.parse((String) data.get("delayDate"), DATE_FORMATTER), // LocalDate
                            (String) data.get("reason") // Second String
                    );
                    // Set additional fields via setters, assuming DelayRecord provides them.
                    if (data.containsKey("id")) {
                        record.setId((String) data.get("id"));
                    }
                    if (data.containsKey("entryTimestamp")) {
                        record.setEntryTimestamp(LocalDateTime.parse((String) data.get("entryTimestamp"), DATETIME_FORMATTER));
                    }
                    delayRecords.add(record);
                }
            }
            System.out.println("Repository: Found " + delayRecords.size() + " DelayRecords for date " + date);
            return delayRecords;
        } catch (ConnectionException e) {
            // Propagate the ConnectionException up
            System.err.println("Repository: Failed to find data by date due to connection error: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Finds a Student by ID. Converts the student ID to a query map,
     * fetches data from SMOS, and then converts the resulting map to a Student entity.
     *
     * @param studentId The ID of the student to find.
     * @return The Student object or null if not found.
     * @throws ConnectionException if the SMOS server connection fails.
     */
    @Override
    public Student findStudentById(String studentId) throws ConnectionException {
        System.out.println("Repository: Finding Student by ID: " + studentId);

        Map<String, Object> studentIdQuery = new HashMap<>();
        studentIdQuery.put("studentId", studentId);

        try {
            // SMOSConnector -> SMOS (fetchData)
            List<Map<String, Object>> studentDataList = smosServerConnector.fetchData(studentIdQuery);

            // Assuming findStudentById returns a list with at most one student record
            return studentDataList.stream()
                    .filter(data -> Objects.equals(data.get("studentId"), studentId) && data.containsKey("name"))
                    .map(data -> new Student(
                            (String) data.get("studentId"),
                            (String) data.get("name"),
                            (String) data.get("parentContactInfo")
                    ))
                    .findFirst()
                    .orElse(null); // Return null if student not found
        } catch (ConnectionException e) {
            // Propagate the ConnectionException up
            System.err.println("Repository: Failed to find student by ID due to connection error: " + e.getMessage());
            throw e;
        }
    }
}
